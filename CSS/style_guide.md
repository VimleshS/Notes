# Style Guides

* [Beyond the Style Guide](https://24ways.org/2015/beyond-the-style-guide/)
* [**Contextual Styling**](http://csswizardry.com/2015/06/contextual-styling-ui-components-nesting-and-implementation-detail/)
* [**Atomic Design**](http://atomicdesign.bradfrost.com/chapter-1/)
* [**Design Machine**](https://louderthanten.com/articles/story/design-machines)
* [Front-end principles](http://jonyablonski.com/2015/front-end-principles-for-designers/)
* [**Examples**](https://www.designernews.co/stories/55696-design-style-guides-examples)
* [**The Language of Modular Design**](http://alistapart.com/article/language-of-modular-design)
* [**Corpus**](http://corpuscss.com/)
* [ITCSS](http://jordankoschei.com/itcss/)
* [Polymer Catalog](https://elements.polymer-project.org/)

Nobody wants to email back and forth style guides. Confusion about latest version, hard to distribute, hard to edit and change, etc.

Instead, create a living style guide made with real HTML and CSS and you can versioned it.

Why style guide?

* BEFORE: What markup/CSS do I need to write?
* AFTER: Which components is this page made of?

Generic style guides for components for easy styling. Lego, abstract CSS, make it reusable.

Fully designed components aren't reusable cross-project. This is where OOCSS is a good idea.

Some style guides are too abstract. No sense of context. Time consuming to create. Often incomplete. Lack a clear methodology. Random spray of patterns.

Know your content structure!

Atom (Abstract) - Molecule - Organisms - Template - Page (the level where you validate)

```
// Least greppable class names
grep "alert" * -R
grep "label" * -R
grep "success" * -R 
grep "info" * -R 
```

* [**Smarter CSS build with Webpack**](http://bensmithett.com/smarter-css-builds-with-webpack/)
* [**React Style Guide**](https://github.com/pocotan001/react-styleguide-generator)
* [react-styleguidist](https://github.com/sapegin/react-styleguidist)
* [**Thinking beyond Scalable CSS - UI Component like React - Nicolas Gallagher**](https://www.youtube.com/watch?v=L8w3v9m6G04)
* [**Build Scalable, Automated CSS**](https://www.youtube.com/watch?v=Tk_0qYEFtAY)
* [Think modularly](http://webstandardssherpa.com/reviews/think-modularly/)
* [A Component API](https://www.youtube.com/watch?v=XNoX1FRZ8kE)
* [Flakes - Design and Frontend framework](http://getflakes.com/index.html)
* [Sass Guideline](http://sass-guidelin.es/)
* [**IBM Design Language**](http://www.ibm.com/design/language/)
* [Skyline - Evolving CSS Architecture](http://skyline.is/)
* [**Style Guide Resources**](http://styleguides.io/)
* [**Interface Inventory**](http://bradfrost.com/blog/post/interface-inventory/)
* [**Pattern Lab resources**](http://patternlab.io/resources.html)
* [**Atomic Design**](https://vimeo.com/109130093)
* [**Front-end Dev Guidelines**](http://tech.tmw.co.uk/code/TMW-frontend-guidelines/)
* [**What we would change about Rizzo**](http://ianfeather.co.uk/what-we-would-change-about-rizzo/)
* [Yelp style guide](http://www.yelp.com.sg/styleguide)
* [Apple iOS styleguide, sort of.](https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/UIKitUICatalog/index.html#//apple_ref/doc/uid/TP40012857)
* [CSS framework vs UI toolkit](https://vimeo.com/95734680)
* [Cardinal](http://cardinalcss.com/)
* [About HTML semantics and front-end architecture](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)
* [GitHub styleguide](https://github.com/styleguide/css)
* [Chris Coyier's Sass styleguide](http://css-tricks.com/sass-style-guide/)
* [Front-end style guides - Anna Debenham](http://24ways.org/2011/front-end-style-guides/)
* [Typesetting your CSS objects](http://www.edenspiekermann.com/blog/typesetting-your-css-objects)
* [CSS Guidelines](https://github.com/csswizardry/CSS-Guidelines)
* [Selector intent](http://csswizardry.com/2012/07/shoot-to-kill-css-selector-intent/)
* [Depth of applicability](http://smacss.com/book/applicability)
* [Hologram - Ruby gem to generate style guide](http://trulia.github.io/hologram/)
* [How Google Fails at Implementing Its Own Material Design](https://medium.com/@CreativeTim/how-google-fails-at-implementing-its-own-material-design-44bbbf9f6c52)
* [Harry Roberts CSS Guideline](http://cssguidelin.es/)
* [Some basic project agnostic CSS](http://ryanmorr.com/project-agnostic-css-declaration-blocks/)
* [How does CSS architecture look like after bootstrap](https://shellycloud.com/blog/2014/10/how-does-our-css-architecture-look-like-after-getting-rid-of-bootstrap?utm_source=designernews&utm_medium=link&utm_campaign=how-does-our-css-architecture-look-like-after-getting-rid-of-bootstrap)
* [Common practices do not mean best practices](http://cssmojo.com/think-for-yourself/)
* [Specs, styles, etc.](https://news.layervault.com/stories/32533-ask-dn-how-do-you-prepare-specs-for-your-developers)
* [Naming CSS stuff is really hard](http://seesparkbox.com/foundry/naming_css_stuff_is_really_hard)
* [UI Lang](http://uilang.com/)
* [The evolving designer](http://marcelosomers.com/the-evolving-designer)
* [**A curated list of pattern library**](https://github.com/marcelosomers/pattern-library-directory)
* [**Codepen Patterns**](http://codepen.io/patterns/)
* [CSS Audits](http://alistapart.com/article/css-audits-taking-stock-of-your-code)
* [Nice general style and principles](http://dubizzle.uno/#/content/look/design-principles.html)
* [Wyrm](http://wyrmsass.org/)
* [New Mailchimp design guide - inspired by Material Design](http://mailchimp.com/resources/email-design-guide/)
* [Writing CSS and SASS that doesn't suck](http://ashleynolan.co.uk/blog/writing-css-and-sass-that-doesnt-suck)
* [Why I don't use CSS Frameworks](http://warpspire.com/posts/css-frameworks/)
* [GOV.UK elements](http://govuk-elements.herokuapp.com/)
* [**Get design trend from website**](http://stylifyme.com/)
* [Create style guides](http://designmodo.com/create-style-guides/)
* [Why you should use mood boards](http://blog.yummygum.com/post/102354528229/why-you-should-be-using-mood-boards-in-your-design)
* [Style guide template](http://codyhouse.co/gem/css-style-guide-template/)
* [Mixins](http://juicynex.us/juice/)
* [Code Guide by @mdo](http://codeguide.co/)
* [Style guide best practices](http://bradfrost.com/blog/post/style-guide-best-practices/)
* [Organizing CSS color palettes](https://news.layervault.com/stories/41926-organizing-css-color-palettes)
* [Live wire](http://ngenworks.com/blog/live-wires-better-prototyping/)
* [CSS namespaces](http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/)
* [The Standard Manual](http://thestandardsmanual.com/)
* [Creating styleguides](http://alistapart.com/article/creating-style-guides)

## Content - Tone, Voice and editorial style

* [Your style guide is missing something and it's big](https://medium.com/@johnamwill/your-style-guides-missing-something-and-it-s-big-263a6124f6d2#.ue02977gl)

## Design System

More than just a style guide

* [Google Material Design](https://www.google.com/design/spec/material-design/introduction.html)
* [Google Color](https://www.google.com/design/spec/style/color.html#)
* [Google Motion](https://www.google.com/design/spec/motion/material-motion.html#)
* [Salesforce Lightning Design System](https://www.lightningdesignsystem.com/)
* [How to be more organized while designing UI](https://medium.com/sketch-app-sources/how-to-be-more-organized-while-designing-ui-90d2d69cfb4f#.luq47e4du)
* [BBC GEL - Global Experience Language](http://www.bbc.co.uk/blogs/internet/entries/c7c8cbe9-fe4e-478b-8048-e15d7c2cd138)

> It's easier to put together a page from some objects than starting with a blank page. It's also easier to assemble new designs a long time after you haven't worked on the project or if you have to hand it down to another designer.
>
> Using a basic set of objects and parameters forces you to use a lesser amount of types of paragraphs, headers, footers, modals, buttons, or list items that you would use if you made something from scratch. Use something from your library first and if it doesn't work, create a new object. This makes your work more consistent. You will never have 6 types of almost the same text color again.

## Companies' CSS

* [Github CSS](http://markdotto.com/2014/07/23/githubs-css/)
* [CSS at Lonely Planet](http://ianfeather.co.uk/css-at-lonely-planet/)
* [CSS at Ghost](http://dev.ghost.org/css-at-ghost/)
* [CodePen's CSS](http://codepen.io/chriscoyier/blog/codepens-css)
* [Buffer CSS](http://blog.brianlovin.com/buffers-css/)
* [Medium CSS](https://medium.com/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06)
* [Bugsnag CSS](https://bugsnag.com/blog/bugsnags-css-architecture)
* [Github's Primer](http://primercss.io/)
* [Google Style Guide](https://github.com/google/styleguide)
* [Brainly](https://github.com/brainly/style-guide)
* [The Times](http://www.thetimes.co.uk/styleguide)
* [CSS at BBC](https://medium.com/@shaunbent/css-at-bbc-sport-part-1-bab546184e66#.5mca5f4pm)
* [BBC Grandstand](http://bbc.github.io/bbc-grandstand/)

## Playbook

* [Hanno](http://playbook.hanno.co/)
* [Government Playbook](http://playbook.cio.gov/)

## Checklist

* [Decouple **functional CSS** from **visual CSS**](http://www.colmtuite.com/a-more-flexible-development-framework)
* Make use of selector grouping
* No `ul.nav {}`, just `.nav {}`. Browsers read rules from right to left.
* No `.header ul {}`, just `.main-nav {}`.
* No `.widget h2 {}`, just `.widget-title`.
* No `article > p:first-child {}`, just `.intro {}`.
* One selector per line, one rule per line
* `@extend` first, then `@include`, then nested selectors last
* `@mixin` all vendor prefixes. Not using autoprefixer?
* Inception rule - only 3-level deep. Too reliant on HTML structure (fragile), overly specific (too powerful) and not very reusable (not useful).
* Max nested is 50 lines or 1 screenful of editor
* Avoid [contextual styles](http://thesassway.com/intermediate/avoid-nested-selectors-for-more-modular-css), but sometimes they are needed like RWD and themes design.
* Modules, not pages
* Developing a system, rather than individual pages.

## CSS Frameworks

* [SUIT CSS](http://suitcss.github.io/)
* [Topcoat](http://topcoat.io/)
* [Pure](http://purecss.io/)
* [Bootflat](http://bootflat.github.io/documentation.html)
* [Semantic UI](http://semantic-ui.com/)
* [Tachyons](http://tachyons.io/)
* [ButaneCSS - Mobile first CSS with cssnext](https://github.com/ButaneCSS/butanecss)
* [Bulma - A modern CSS framework based on Flexbox](http://bulma.io/)

## Architecture

* [Architecting Sass project](http://www.sitepoint.com/architecture-sass-project/)
* [Pears](http://pea.rs/)
* [Barebones](http://barebones.paulrobertlloyd.com/)

## Examples

* [**Brand Style Guide Examples**](http://saijogeorge.com/brand-style-guide-examples/)
* [Style guides and pattern libraries](https://gimmebar.com/collection/4ecd439c2f0aaad734000022/front-end-styleguides-and-pattern-libraries)
* [Code for America](http://style.codeforamerica.org/)
* [Mapbox](https://www.mapbox.com/base/)
* [Louder than Ten Manual](http://manual.louderthanten.com/)
* [Fiftythree styleguide](http://www.fiftythree.com/styleguide/typography)
* [Eventmobi](https://medium.com/@owdco/how-we-css-at-eventmobi-98a12961c264)
* [Buffer App](https://bufferapp.com/style-guide)
* [Lonely Planet](http://rizzo.lonelyplanet.com/styleguide/design-elements/colours)
* [Atlassian Design](https://design.atlassian.com/latest/)
* [Living Style Guide](http://livingstyleguide.org/)
* [Code guide by @mdo](http://codeguide.co/#css)
* [OpenUI5 from SAP](http://openui5.org/getstarted.html)
* [MediaMath's Strand using Web Components](http://mediamath.github.io/strand/)
* [**Basscss**](http://www.basscss.com/)
* [**Element-UI: React**](http://elemental-ui.com/)

## Naming Convention

* [**From Pages to Patterns**](http://alistapart.com/article/from-pages-to-patterns-an-exercise-for-everyone)

> Name describes its function, not how it looks.
>
> There's a lot to be gained from getting away from our screens and focusing first on thinking, language, and approach.

Component vs Page-level naming. We should not use Page-level if possible. Prefer Component-level names. However, Page-level can be used to override generic components in very specific contexts:

```css
.home-page {          /* Page-level */
  .nav {              /* Component-level */
    margin-top: 10px; /* Override */
  }
}
```

```
.blue-button vs .button
.profile-card vs .product-card vs .location-card vs .card
```

* [Naming CSS stuff is really hard](http://seesparkbox.com/foundry/naming_css_stuff_is_really_hard)

We can fit a given class name into these 3 categories:

1. Functional class names (thinking in system, not pages) - `positive-button`
2. Content-based class names - `submit-button`
3. Presentational class names - `green-button`

Structured components consist of the following elements:

* Components - A page module that has a certain purpose and is a wrapper for it's children. Make it as independent as possible.
* Nested elements - Parts of which a component can consist, sometimes similar across components.
* Variants - A component and its containing elements which are modified in a certain way.
* States - The state of a component or nested element is modified by user interaction.

```
// Components
.component-name {}      // .inspector {}

// Variants
.component--variant {}  // .inspector--without-border {}

// Nested elements
// Instead of .component .link {}, we use double underscore
.component__link {}     // .inspector__header {}

// Modifiers or state
.component.is-active {}
.component-name.has-children {}
.component-name.js-selected {}
	
.btn {}
.btn-large {}
.btn-is-active {} // instead of .is-active or .is-btn-active
```

OOCSS has many in non-semantic classes. One of the cited downsides of OOCSS is that these classes don't tell you anything about the content. However, semantic is a fallacy. We should write classes that are useful for developers; classes that are:

* Highly reusable
* Don't couple to specific types of content
* Describe the styling's function rather than the content's function.

```
ui-list
ui-inspector
ui-modal
```

All these describe content, thus is not scalable:

```html
<ul class="jobs">
<ul class="candidates">
```    

When you describe the content, you cannot reuse the class name. Rather, derive class name semantics from repeating structural and functional patterns in a design.

> The most reusable components are those with class names that are independent of the content - Nicolas Gallagher

The aim of a component/template/object-oriented architecture is to be able to develop a **limited number** of reusable components that can contain a range of different content types.

```js
:root {
  /* Colors */
  --canvas-color: #fff; /* Name your variable according to function instead of visual presentation */
  --text-color: #000;
  --main-color: yellow; /* Indicate the main Jobline brand color (themes) */

  /* Typography */
  --base-font-size: 16px;
}
```

More real-world examples:

```css
/* From Medium */
.screenContent
.is-supplementalPostContentLoaded
.js-metabar
.metabar--centered
.u-sizeViewHeightMin100
.postArticle
.postArticle--full
.postArticle--response
.section--body
.section--first
.section--last
.layoutSingleColumn
```

### Avoid run-on classnames

The evolution being: `.button` → `.button-primary` → `.button-primary-dark` → `.button-primary-dark-container` → `.button-primary-dark-container-label`, ad nauseam.

# My Style Guide

* Base - normalize and element selector. Base are not for button, table, input, those are modules.
* Layout - Application shell and grid system. No call-out, no drawer, etc. Just the shell structure. A lot broader than module. Module is more constrained to its content.
* Module - List views, buttons, tabs, content container. Always 100% width. Leave the width constraint to Layout. Modules expand to fill Layout. Module should decide what margin they should have instead of letting Layout to decide.
* Color-Variables

Similar patterns repeating over different content type. So don't name your class too specific according to the content.

At one glance, you may think you have only one style for button or input style.

**Decoupling CSS from HTML**

```
/* BAD - coupling CSS with HTML! */
.nav ul {}
.nav li {}
.nav li a {}

.nav li li {}
.nav li li a {}

/* Better - Use child selector */
.nav > li {}
.nav > li > a {}

.menu {}
.menu > li > a {}
```

**Drop-down**

Have a wrapper for drop-down behavior and isolate modules

```
.nav__dropdown { display: none; }
.nav > li:hover > .nav__dropdown { display: block; }
/* This is the module. Even if it is hidden, it is still display: block */
.megadropdown {}
```

```
<div class="nav__dropdown">
  <div class="megadropdown"></div>
</div
```